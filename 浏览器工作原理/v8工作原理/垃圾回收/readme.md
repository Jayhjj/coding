# 垃圾回收

1. 手动回收(例如: c/c++)

2. 自动回收(例如: js,java,python)


# 栈中的垃圾数据 和 堆中的垃圾数据如何回收

栈中的垃圾数据:
    js引擎会通过向下移ESP指针来销毁函数保存在栈中的执行上下文

堆中的垃圾数据:



# 代际假说 和 分代收集

代际假说(策略/人为的一种认知): 
1. 大部分对象在内存中存在的时间很短，简单来说就是很多对象一经分配内存，很快就变得不可访问
2. 不死的对象会活得更久

v8 会把堆分成  新生代 和 老生代 两个区

新生代: 存放时间短的对象   1-8M 的容量  被副垃圾回收器回收
老生代: 存放时间长的对象    很大        被主垃圾回收器回收

# 垃圾回收器的工作原理
不论什么类型的垃圾回收器，独有一套共同的执行过程
1. 标记空间中的活动对象(还在使用的对象) 和非活动对象(可以进行垃圾回收的对象)
2. 回收非活动对象所占据的内存
3. 做内存整理，频繁回收对象后，就会出现大量不连续的空间(内存碎片)


# 副垃圾回收器
主要负责新生区的垃圾回收，通常情况下，大多数小的对象都会被分配到新生区,但是回收是很频繁的，scavenge算法会把 新生区的内存一分为二，分成对象区域和空闲区域，然后标记对象区域里面的所有对象,把活对象复制到空闲区域,此过程还会做好排序,相当于是做了内存整理,然后清空对象区域,再角色翻转

当存活对象过多,新生区空间不够时,js会采用对象晋升策略 (经过两次垃圾回收还存活的对象直接移动到老生区)


# 主垃圾回收器
主要负责老生区的垃圾回收，老生区的对象来自新生区晋升对象和一些很强大的对象

标记-清除的算法，首先是标记阶段(递归遍历的区域标记一组对象，但凡是能找到一个节点是活动对象，一个活动节点都没有成为垃圾数据)


# 全停顿
因为 js 是运行在v8的主线程上的，而垃圾回收的算法也在主线程，那么就会出现当需要垃圾回收时，js的运行会停顿，等到垃圾回收完毕后再恢复后再恢复运行 --- 全停顿

全停顿在新生区是没有太大的影响的，v8将标记过程分成一个个子标记过程，同时让垃圾回收标记和js应用逻辑交替进行，直到标记完成(增量标记算法)